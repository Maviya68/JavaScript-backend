JavaScript notes : 
typeof null = object // try verifying this.
null is a standalone value ? not a type ?

2**2 means 2^2 // JavaScript

comparing values of different data types lead to inconsistent/surprising results => avoid them.
eg: (null == 0) => avoid these comparisons.

datatype verification : read Ecmascript for that.

Memory : 
Stack : primitive data types are stored here, it makes a copy when the variable is used in assignation of another variable.
Heap : non-primitive data types are stored here, when a non-primitve data type var is used in assignation of another variable it gives the same heap ref which is stored in the first variable.

Use backtick(``) string interpolation => (`-string-${var}-string-`)

// learn all string functions //done

* To get random integer value between a max num and min num do : 
(Math.floor(Math.random() * (max-min+1)) + min)

Understand this..                                                             (because its factor math.random() ranges from 0 to 1 only, and not more than 1)
*Math.random()*number     => the result will always be a percentage of number=20 ^ hence it will be min = 0 and max = 20(1*20)
  (0 => 1)    20(say)



Dates In JS 
* In the Date(constuctor) we can also set any specific date we want.
* Various methods are given by date object to get date in different formats.
* We can customize the dates when using ToLocaleString method using its parameters. // Try it.

Arrays 
Shallow Copy => same reefernce point.
Deep Copy => different reefernce point.

slice(original array remains same) vs splice(takes the selection from the original array so it is left changed , also includes the end index which slice doesn't) 

Objects 
values of object properties can also be accessed thorugh object_name["key_in_string"]
* Adding a symbol as a key in a object also is done by defining the key as { [symbol_name] : value }
why use symbols here ?? => dont know right now.

Object.freeze(object_name) => makes all properties unchangeable in the future / constant maybe

Important{
Object.keys(obj_name) returns all the keys in a string array.
Object.values(obj_name) returns all the values in a string array.
obj_name.hasOwnProperty() => tells us if a given key is available or not in the object. returns boolean.

}

Destructuring objects => gives a smaller and simpler syntax for taking out properties using without object name and if we define a reference then we can use that reference also.

=> const {property_name | : nick_name (optional)} = object_name

... has two names Rest Operator and Spread Operator according to its use case.
inside function parameter before a parameter = Rest Operator.
before an array = Spread Operator.


arrow function notation :

normal : (parameter(s)) => {}
shorthand for return only body : (parameter(s)) => (-any value to be returned/even Objects-)
If we use the above notation : 
1. We dont have to use the return keyword.
2. everything inside '()' will be returned 
eg : const add = (num1,num2) => (num1+num2)
log(add);